# Simple Calculator Example

This example demonstrates the Cylon Raider methodology by implementing a simple calculator application.

## Overview

This example shows how the three roles collaborate:
- **Commander**: Evaluates the project scope and requirements
- **Pilot**: Designs the architecture and component structure  
- **Gunner**: Implements the code and tests

## Running the Example

```bash
# Trigger the workflow with a calculator feature
gh workflow run cylon-development.yml \
  -f feature_description="Build a calculator that can add, subtract, multiply and divide two numbers" \
  -f priority="medium"
```

## Expected Workflow

### 1. Commander Review
The Commander will:
- Evaluate if a calculator aligns with project goals
- Assess the complexity (should be "simple")
- Approve the feature and suggest a branch name like `feature/calculator`

### 2. Pilot Architecture
The Pilot will:
- Break down the calculator into components (UI, operations, validation)
- Identify technologies needed (Python, testing framework)
- Design the interface between components
- Create implementation specifications for the Gunner

### 3. Gunner Implementation
The Gunner will:
- Implement the calculator class with methods for each operation
- Add input validation and error handling
- Write comprehensive unit tests
- Create usage examples and documentation

## Expected Output Structure

```
calculator/
├── src/
│   ├── calculator.py          # Main calculator class
│   └── validation.py          # Input validation
├── tests/
│   ├── test_calculator.py     # Unit tests
│   └── test_validation.py     # Validation tests
├── docs/
│   ├── architecture/
│   │   └── 20250105-calculator-architecture.md
│   ├── implementation/
│   │   └── 20250105-calculator-implementation.md
│   └── usage.md               # Usage examples
└── README.md                  # Project documentation
```

## Sample Code Structure

### Calculator Class (Generated by Gunner)
```python
class Calculator:
    """A simple calculator for basic arithmetic operations."""
    
    def add(self, a: float, b: float) -> float:
        """Add two numbers."""
        return a + b
    
    def subtract(self, a: float, b: float) -> float:
        """Subtract b from a."""
        return a - b
    
    def multiply(self, a: float, b: float) -> float:
        """Multiply two numbers."""
        return a * b
    
    def divide(self, a: float, b: float) -> float:
        """Divide a by b."""
        if b == 0:
            raise ValueError("Cannot divide by zero")
        return a / b
```

### Tests (Generated by Gunner)
```python
import pytest
from calculator import Calculator

class TestCalculator:
    def setup_method(self):
        self.calc = Calculator()
    
    def test_add(self):
        assert self.calc.add(2, 3) == 5
        assert self.calc.add(-1, 1) == 0
    
    def test_divide_by_zero(self):
        with pytest.raises(ValueError, match="Cannot divide by zero"):
            self.calc.divide(5, 0)
```

## Review Process

### Experiment → Feature PR
After the Gunner implements the calculator:
1. An experiment branch is created: `experiment/calculator-implementation`
2. Code and tests are committed to this branch
3. A PR is created from experiment → feature branch
4. The Pilot reviews the implementation against specifications

### Feature → Main PR
After Pilot approval:
1. The experiment is merged into the feature branch
2. A PR is created from feature → main branch  
3. The Commander does final review for production readiness
4. Upon approval, the feature is merged to main

## Learning Outcomes

This example demonstrates:
- **Role separation**: Each AI has distinct responsibilities
- **Quality gates**: Two-level PR review process
- **Documentation**: Automatic generation of architecture and implementation docs
- **Testing**: TDD approach with comprehensive test coverage
- **Git workflow**: Three-workspace branching strategy

## Variations to Try

Try different feature descriptions to see how the roles adapt:

```bash
# Simple variation
gh workflow run cylon-development.yml \
  -f feature_description="Add memory functions to the calculator (store, recall, clear)"

# Complex variation  
gh workflow run cylon-development.yml \
  -f feature_description="Build a scientific calculator with trigonometric functions"

# Different domain
gh workflow run cylon-development.yml \
  -f feature_description="Create a todo list manager with add, complete, and delete functions"
```

## Tips for Success

1. **Be specific** in feature descriptions - the AI works better with clear requirements
2. **Check the logs** - GitHub Actions will show the AI reasoning process
3. **Review the PRs** - The generated code should be reviewed like any human-written code
4. **Iterate** - Use the feedback to improve your prompts and system configuration

This example shows how the Cylon Raider methodology can produce well-structured, tested, and documented code through disciplined AI collaboration.
